# JS运行机制
## 一. 进程与线程
### 进程
进程是`CPU`资源分配的最小单位，包含了运行程序所使用到的内存和系统资源

### 线程
线程是`CPU`任务调度的最小单位，是建立在进程的基础上的一次程序执行单位

### 进程与线程的区别
进程由一个或多个线程组成，进程之间相互独立，同一进程下的多个线程共享程序的资源

## 二. 浏览器多进程
### 浏览器包含哪些进程
- Browser进程
  - 浏览器的主进程（负责协调、主控），该进程只有一个
  - 负责浏览器页面显示，与用户交互
  - 负责各个页面管理，创建或销毁其他进程
  - 将渲染进程得到的内存中的`Bitmap`绘制到用户界面上
  - 网络资源的管理、下载等

- 第三方插件进程
  - 每个类型的插件对应一个进程，当使用该插件时才创建

- GPU进程
  - 用于3D绘制等，该进程只有一个

- 渲染进程（浏览器内核）
  - 每个Tab页面都有一个渲染进程，互不影响
  - 主要作用是页面渲染、脚本执行和事件处理等

### 浏览器多进程优势
- 避免单个页面奔溃影响整个浏览器
- 避免单个插件奔溃影响整个浏览器
- 方便使用沙盒模式隔离插件等进程，提升浏览器稳定性
- 多进程可以充分利用多核优势

## 三. 渲染进程
### 渲染进程包含哪些线程
- GUI渲染线程
  - 负责渲染浏览器页面，解析HTML、CSS，构建DOM树Render树，布局和绘制等
  - 当界面重绘或回流时，该进程会执行
  - GUI线程和JS引擎线程是互斥的，当JS引擎线程执行时，CUI线程会挂起，GUI更新会保存在一个队列中等JS引擎空闲时执行

- JS引擎线程
  - 负责处理JavaScript脚本程序
  - GUI线程和JS引擎线程是互斥的，当JS执行时间过长时，会造成页面渲染不连贯

- 事件触发线程
  - 归属浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列
  - 当JS引擎执行一些事件绑定或异步操作时（如`setTimeout`、鼠标点击或`XMLHttpRequest`请求等）会通过事件触发线程将对应事件添加到对应的线程中（比如定时器操作，会把定时器任务添加到定时器触发线程中），等异步事件有了结果，再把回调添加到事件队列中，等待JS引擎执行

- 定时器触发线程
  - `setTimeout`和`setInterval`所在的线程
  - 浏览器定时计数器并不是JS引擎计数的，因为JS引擎是单线程，如果处于阻塞状态会影响计时的准确性
  - 通过单独线程来计时并触发定时，计时完毕后，添加到事件队列中，等JS引擎空闲时执行
  - W3C标准中`setTimeout`最小间隔时间是`4ms`

- 异步Http请求线程
  - 在`XMLHttpRequest`连接后通过浏览器新开一个线程
  - 当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调放入事件队列中，等待JS引擎执行

![浏览器内核](https://segmentfault.com/img/remote/1460000012925880)

## 四. Event Loop
JS任务分为同步任务和异步任务，同步任务都在主线程上执行，形成执行栈。事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就会在任务队列中放入一个回调事件。等执行栈任务执行完毕后，系统会读取任务队列，将可执行的异步任务添加到执行栈中

![Event Loop](https://segmentfault.com/img/remote/1460000012925883)

## 五. 宏任务和微任务
### 宏任务
可以理解每次执行栈执行的代码是一次宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈执行）
  - 每个任务都会从头到尾执行完毕，不会执行其他
  - 由于GUI线程和JS引擎线程互斥，为了宏任务和DOM渲染能够有序进行，会在一个宏任务执行完毕后，在下一个宏任务执行前，触发GUI线程，对页面重新渲染

常见的宏任务
  - 主代码块
  - setTimeout、setInterval等

### 微任务
微任务有独立的任务队列，会在宏任务执行完毕后，在渲染之前执行完。

常见的微任务
  - Promise
  - Object.observe
  - MutationObserve

![Event Loop](https://segmentfault.com/img/remote/1460000012925885)